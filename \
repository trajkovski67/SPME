module PME_main
    use iso_fortran_env, only : output_unit, error_unit
    use print_matrix, only : write_vector, write_matrix
    use, intrinsic :: iso_c_binding, only: c_loc, c_double_complex, c_int, c_ptr,c_double
    
    implicit none
    private
    public :: PME_prog
    integer, parameter :: wp = selected_real_kind(15)
contains

        
subroutine PME_prog(input)
    implicit none
    integer, intent(in) :: input
    real(wp) :: a, b, c, alpha, beta, gamma, volume,qq,rr,direct_sum,x,y,z,a1(3),re,im,explicit_sum
    integer :: io,i,j,k,l,u,o,p,no_ion,K1,K2,K3,m1,m2,m3,n1,n2,n3,K_big,k_small,Rcut,Gcut
    real(wp),allocatable :: ion_frac_coord(:,:), ion_coord(:,:), phi_rec(:,:,:),coord_rec(:,:),Q(:,:,:),test(:),convolved(:,:,:)
    real(wp) :: coord(3,3), distance_of_a_pair(3), g_squared, ewald_coeff, pi = 3.14159265359_wp,rec_vector(3),f1,f2,f3,qi,g1(3),g2(3),g3(3),convolved_sum, rec_sum,benchmark,translation_vector(3)
    complex(wp), parameter :: imaginary = (0.0_wp, 1.0_wp)
    complex(wp) :: phase
    complex(wp), allocatable ::  phi_rec_complex(:,:,:), Q_complex(:,:,:), convolved_complex(:,:,:)
    character(len=100) :: line,bravais
    read(input, '(A)') line
    read(line, *, iostat=io) bravais
    !READER______________________________________________________________________START
    if (trim(adjustl(bravais)) == 'tetragonal') then
        read(input, '(A)') line
        read(line, *, iostat=io) a,c
        b = a
        alpha = 90.0
        beta = alpha
        gamma = alpha
        volume = a*b*c
        read(input, '(A)') line
        read(line, *, iostat=io) no_ion
        allocate(ion_frac_coord(no_ion,4))
        do i = 1, no_ion
            read(input, '(A)') line
            read(line, *, iostat=io) ion_frac_coord(i,1), ion_frac_coord(i,2), ion_frac_coord(i,3), ion_frac_coord(i,4)
        end do
        coord = 0.0_wp
        do i=1,2
            coord(i,i) = a
        end do
        coord(3,3) = c
    end if

    if (trim(adjustl(bravais)) == 'NaCl') then
        read(input, '(A)') line
        read(line, *, iostat=io) a
        b = a
        c = a
        alpha = 90.0
        beta = 90.0
        gamma = 90.0
        volume = a*b*c
        read(input, '(A)') line
        read(line, *, iostat=io) no_ion
        allocate(ion_frac_coord(no_ion,4))
        do i = 1, no_ion
            read(input, '(A)') line
            read(line, *, iostat=io) ion_frac_coord(i,1), ion_frac_coord(i,2), ion_frac_coord(i,3), ion_frac_coord(i,4)
        end do
        coord = 0.0_wp
        do i=1,3
            coord(i,i) = a
        end do
    end if
    read(input, '(A)') line
    read(line, *, iostat=io) k1, k2, k3
    read(input, '(A)') line
    read(line, *, iostat=io) ewald_coeff, p, Rcut, Gcut
!call write_matrix(ion_frac_coord, name = "ion fractional coordinates and charge (x,y,z,chrg)")
!call write_matrix(coord, name = "cartesian components of the unit cell vectors (x,y,z)")
!READER__________________________________________________________________________END

!VOLUME_OF_THE_UNIT_CELL_________________________________________________________START
!call compute_cross_product(coord(1:3,1),coord(1:3,2),a1)
!volume = dot_product(a1,coord(1:3,3))
!VOLUME_OF_THE_UNIT_CELL_________________________________________________________END

!DEFINITION_OF_RECIPROCAL_LATTICE________________________________________________START
allocate(coord_rec(3,3))
coord_rec = 0.0_wp
call compute_cross_product(coord(1:3,1),coord(1:3,2),coord_rec(1:3,3))
call compute_cross_product(coord(1:3,1),coord(1:3,3),coord_rec(1:3,2))
call compute_cross_product(coord(1:3,2),coord(1:3,3),coord_rec(1:3,1))
coord_rec = abs(coord_rec)/volume
call write_matrix(coord_rec,name = "reciprocal vectors")
!DEFINITION_OF_RECIPROCAL_LATTICE________________________________________________END

!ION_VECTORS_IN_THE_UNIT_CELL____________________________________________________START
allocate(ion_coord(no_ion,3))
do i = 1, no_ion
    do j = 1, 3
        ion_coord(i,1:3) = ion_coord(i,1:3) + ion_frac_coord(i,j) * coord(:,j)
    end do
end do
call write_matrix(ion_coord,name='ion_coord')
!ION_VECTORS_IN_THE_UNIT_CELL____________________________________________________END

!DIRECT_SPACE_SUMMATION__________________________________________________________START
direct_sum = 0.0_wp
do i = 1,no_ion
    do j = i+1, no_ion
        do n1 = -Rcut,Rcut
            do n2 = -Rcut,Rcut
                do n3 = -Rcut,Rcut
                        distance_of_a_pair(:) = ion_coord(i,1:3) -ion_coord(j,1:3)
                        translation_vector(:) = n1*coord(1,1:3) + n2*coord(2,1:3)+n3*coord(3,1:3)
                        qq = ion_frac_coord(i,4) * ion_frac_coord(j,4)
                        rr = sqrt(dot_product(distance_of_a_pair+translation_vector,distance_of_a_pair+translation_vector))
                        direct_sum = direct_sum + qq * erfc(ewald_coeff*rr)/rr
                end do
            end do
        end do
    end do
end do

!SELF_INTRACTION_CORRECTION______________________________________________________START
do i = 1, no_ion
    direct_sum = direct_sum - ewald_coeff * (ion_frac_coord(i,4))**2/sqrt(pi)
end do

!SELF_INTRACTION_CORRECTION______________________________________________________END

!RECIPROCAL_POTENTIAL____________________________________________________________START
allocate(phi_rec_complex(0:k1-1,0:k2-1,0:k3-1))
phi_rec_complex = (0.0_wp, 0.0_wp)
!the vectors are given by the rows, the columns are the x,y,z components, here g1 are the x
!components of the reciprocal vectors and so on.
g1 = coord_rec(1:3,1)
g2 = coord_rec(1:3,2)
g3 = coord_rec(1:3,3)
do i = 0, k1-1
    do j = 0, k2-1
        do k = 0, k3-1
            f1 = real(i+1, wp) / real(k1, wp)
            f2 = real(j+1, wp) / real(k2, wp)
            f3 = real(k+1, wp) / real(k3, wp)
            do m1 = -Gcut,Gcut
                do m2 = -Gcut,Gcut
                    do m3 = -Gcut,Gcut
                        if (m1 /= 0 .or. m2 /= 0 .or. m3 /= 0) then
                                rec_vector = m1*g1 + m2*g2 + m3*g3
                                !call write_vector(rec_vector, name='rec_vector')
                                phase = 2*pi*(m1*f1+m2*f2+m3*f3)
                                g_squared = dot_product(rec_vector,rec_vector)
                                phi_rec_complex(i,j,k) = phi_rec_complex(i,j,k) + exp(-pi**2*g_squared/ewald_coeff**2)*exp(phase*imaginary)/(volume*pi*g_squared)
                        end if
                    end do
                 end do
            end do
        end do
    end do
end do
!RECIPROCAL_POTNETIAL____________________________________________________________END

!PROJECTION_OF_CHARGES_ONTO_THE_GRID_____________________________________________START
allocate(Q(0:k1,0:k2,0:k3))
Q = 0.0_wp
do i = 1, no_ion
    f1 = ion_frac_coord(i,1)
    f2 = ion_frac_coord(i,2)
    f3 = ion_frac_coord(i,3)
    qi = ion_frac_coord(i,4)
    do j = 0, k1-1
        do k = 0, k2-1
            do l = 0, k3-1
                Q(j,k,l) = Q(j,k,l) + qi*theta_p_K(f1,p,k1,j+1)*theta_p_K(f2,p,k2,k+1)*theta_p_K(f3,p,k3,l+1)
            end do
        end do
    end do
end do
allocate(convolved_complex(0:k1,0:k2,0:k3))
convolved_complex=(0.0_wp, 0.0_wp)
!PROJECTION_OF_CHARGES_ONTO_THE_GRID_____________________________________________END
!RECIPROCAL_SUM__________________________________________________________________START
rec_sum = 0.0_wp
call fft_convolve_3d(k1,k2,k3, phi_rec_complex, cmplx(Q,0.0_wp,kind=wp), convolved_complex)
print*, 'convolved sum is' , sum(real(convolved_complex))
do i = 0, k1-1
    do j = 0, k2-1
        do k = 0, k3-1
            do l = 1, no_ion
                f1 = ion_frac_coord(l,1)
                f2 = ion_frac_coord(l,2)
                f3 = ion_frac_coord(l,3)
                qi = ion_frac_coord(l,4)
                rec_sum = rec_sum + qi*theta_p_K(f1,p,k1,i+1)*theta_p_K(f2,p,k2,j+1)*theta_p_K(f3,p,k3,k+1)*real(convolved_complex(i,j,k))*0.5_wp
                !rec_sum = rec_sum + Q(i,j,k)*convolved(i,j,k)/2
            end do
        end do
    end do
end do
!RECIPROCAL_SUM__________________________________________________________________END

print*,'total charge of the grid', sum(Q)
!print*, Q
!print*, real(phi_rec_complex)
!print*, real(convolved_complex)
call reciprocal_ewald(no_ion,ion_frac_coord,ion_coord,coord,coord_rec,Gcut,ewald_coeff,volume,benchmark)
print*, 'ELECTROSTATIC ENERGY: PME', direct_sum + rec_sum
print*, "ELECTROSTATIC ENERGY: EWALD", benchmark + direct_sum
print*, 'DIRECT SPACE', direct_sum
print*, 'RECIPROCAL SPACE: PME:', rec_sum
print*, 'RECIPROCAL SPACE: EWALD', benchmark
print*, "RECIPROCAL SPACE: PME-EWALD",rec_sum-benchmark

end subroutine PME_prog

subroutine reciprocal_ewald(no_ion,ion_frac_coord,ion_coord,coord,coord_rec,Gcut,ewald_coeff,volume,resultat)
implicit none
real(wp), intent(in) :: ion_coord(:,:), ion_frac_coord(:,:), coord_rec(:,:),coord(:,:), ewald_coeff, volume
integer, intent(in) :: no_ion, Gcut
real(wp), intent(out) :: resultat
integer :: m1, m2, m3, i
real(wp) :: g1(3), g2(3), g3(3), rec_vector(3), g_squared,pi = 3.14159265359_wp
complex(wp), parameter :: imaginary = (0.0_wp, 1.0_wp)
complex(wp) :: S, resultat_complex
! Extract reciprocal basis once
g1 = coord_rec(1:3,1)
g2 = coord_rec(1:3,2)
g3 = coord_rec(1:3,3)
resultat_complex = (0.0_wp, 0.0_wp)
do m1 = -Gcut, Gcut
  do m2 = -Gcut, Gcut
    do m3 = -Gcut, Gcut
      if (m1 /= 0 .or. m2 /= 0 .or. m3 /= 0) then
        rec_vector = m1*g1 + m2*g2 + m3*g3
        g_squared = dot_product(rec_vector, rec_vector)
        S = (0.0_wp, 0.0_wp)
        do i = 1, no_ion
          S = S + ion_frac_coord(i,4) * exp(2.0_wp * pi * imaginary * dot_product(rec_vector, ion_coord(i,1:3)))
        end do
        resultat_complex = resultat_complex + 0.5_wp * exp(-pi**2 * g_squared / ewald_coeff**2) * (S * conjg(S)) / (volume * pi * g_squared)
      end if
    end do
  end do
end do
resultat = real(resultat_complex)
end subroutine reciprocal_ewald
!subroutine convolution_complex(array1,array2,k1,k2,k3,convolved)
!    implicit none
!    complex(wp), intent(in) , array1(:,:,:), array2(:,:,:)
!    integer :: i, j, k ,l, n
!    real(wp),allocatable, intent(out) :: convolved(:,:,:)
!    integer, intent(in) :: k1, k2, k3
!    external zffti, zfftf, zfftb
!    complex(wp), allocatable :: array1_packed(:), array2_packed(:), wsave1(:), wsave2(:), wsave3(:)
!    complex(wp) ::  fft(k1*k2*k3)
!    n = k1*k2*k3
!    allocate(convolved(k1,k2,k3))
!    allocate(array1_packed(n))
!    allocate(array2_packed(n))
!    allocate  allocate(wsave2(4*n+15))
!    allocate(wsave3(4*n+15))
!    array1_packed = reshape(array1,[n])
!    array2_packed = reshape(array2,[n])
!    call zffti(n,wsave1)
!    call zffti(n,wsave2)
!    call zfftf(n,array1_packed,wsave1)
!    call zfftf(n,array2_packed,wsave2)
!    do i = 1, n
!        fft(i) = array1_packed(i)*array2_packed(i)
!    end do
!    call zffti(n,wsave3)
!    call zfftb(n,fft,wsave3)
!    convolved = reshape(real(fft/n),[k1,k2,k3])
!end subroutine convolution_complex
subroutine fft_convolve_3d(nx, ny, nz, A, B, C)
  use, intrinsic :: iso_c_binding, only: c_double_complex, c_double, c_int, c_ptr, c_loc
  implicit none

  ! Arguments
  integer(c_int), intent(in) :: nx, ny, nz
  complex(c_double_complex), intent(in) :: A(nx,ny,nz), B(nx,ny,nz)
  complex(c_double_complex),allocatable, intent(out) :: C(:,:,:)

  complex(c_double_complex), allocatable, target :: FA(:,:,:), FB(:,:,:), FC(:,:,:)
  type(c_ptr) :: plan_fwd_A, plan_fwd_B, plan_inv
  integer :: i, j, k
  integer(c_int) :: nxyz
  ! Interface to FFTW
  interface
    function fftw_plan_dft_3d(n1, n2, n3, in, out, sign, flags) bind(C, name="fftw_plan_dft_3d")
      use iso_c_binding
      integer(c_int), value :: n1, n2, n3, sign, flags
      type(c_ptr), value :: in, out
      type(c_ptr) :: fftw_plan_dft_3d
    end function

    subroutine fftw_execute_dft(plan, in, out) bind(C, name="fftw_execute_dft")
      use iso_c_binding
      type(c_ptr), value :: plan, in, out
    end subroutine

    subroutine fftw_destroy_plan(plan) bind(C, name="fftw_destroy_plan")
      use iso_c_binding
      type(c_ptr), value :: plan
    end subroutine
  end interface

  ! Constants
  integer(c_int), parameter :: FFTW_FORWARD = -1, FFTW_BACKWARD = 1
  integer(c_int), parameter :: FFTW_ESTIMATE = 64

  nxyz = nx * ny * nz 

  ! Allocate arrays
  allocate(C(0:nx-1,0:ny-1,0:nz-1))
  allocate(FA(0:nx-1,0:ny-1,0:nz-1))
  allocate(FB(0:nx-1,0:ny-1,0:nz-1))
  allocate(FC(0:nx-1,0:ny-1,0:nz-1))
  ! Copy input to temp arrays for FFTW (must be target)
  FA = A
  FB = B

  ! Create FFTW plans
  plan_fwd_A = fftw_plan_dft_3d(nx, ny, nz, c_loc(FA(0,0,0)), c_loc(FA(0,0,0)), FFTW_FORWARD, FFTW_ESTIMATE)
  plan_fwd_B = fftw_plan_dft_3d(nx, ny, nz, c_loc(FB(0,0,0)), c_loc(FB(0,0,0)), FFTW_FORWARD, FFTW_ESTIMATE)
  plan_inv   = fftw_plan_dft_3d(nx, ny, nz, c_loc(FC(0,0,0)), c_loc(FC(0,0,0)), FFTW_BACKWARD,FFTW_ESTIMATE)

  ! Execute forward FFTs
  call fftw_execute_dft(plan_fwd_A, c_loc(FA(0,0,0)), c_loc(FA(0,0,0)))
  call fftw_execute_dft(plan_fwd_B, c_loc(FB(0,0,0)), c_loc(FB(0,0,0)))

  ! Multiply in frequency domain
  do i = 0, nx-1
    do j = 0, ny-1
      do k = 0, nz-1
        FC(i,j,k) = FA(i,j,k) * FB(i,j,k)
      end do
    end do
  end do
  ! Inverse FFT to get convolution result
  call fftw_execute_dft(plan_inv, c_loc(FC(0,0,0)), c_loc(FC(0,0,0)))

  ! Normalize
  C = FC / real(nxyz, c_double)
  ! Cleanup
  call fftw_destroy_plan(plan_fwd_A)
  call fftw_destroy_plan(plan_fwd_B)
  call fftw_destroy_plan(plan_inv)

  deallocate(FA, FB, FC)
end subroutine fft_convolve_3d

subroutine compute_cross_product(a, b, c)
  implicit none
  real(wp), intent(in)  :: a(3), b(3)
  real(wp), intent(out) :: c(3)
  c(1) = a(2)*b(3) - a(3)*b(2)
  c(2) = a(3)*b(1) - a(1)*b(3)
  c(3) = a(1)*b(2) - a(2)*b(1)
end subroutine compute_cross_product

function binomial(n, k) result(b)
    implicit none
    integer, intent(in) :: n, k
    integer :: i
    real(wp) :: b
    if (k < 0 .or. k > n) then
        b = 0
    else if (k == 0 .or. k == n) then
        b = 1
    else
        b = 1
        do i = 1, k
            b = b * (n - i + 1) / i
        end do
    end if
end function binomial

function integer(x,p,K) result(k_integer)
    implicit none
    integer, intent(in) :: K,p
    real(wp), intent(in) :: x  
    integer :: k_integer
    real(wp) :: dummy
    dummy = x*K
    k_integer = floor(dummy)-p+1
end function integer


function phi_p_K(x,p,K_big,k_small) result(phi)
    implicit none
    integer, intent(in) :: p , K_big, k_small
    integer :: l, maxi,i
    real(wp), intent(in) :: x
    real(wp) :: phi,maxi_real, N,l_real, K_big_real, k_small_real
    K_big_real = real(K_big,wp)
    k_small_real = real(k_small,wp)
    N = 0.0_wp
    maxi = 2*p-1
    phi = 0.0_wp
    maxi_real =real(maxi,wp)
    if ((k_small > maxi) .or. (k_small < 0) ) then
        phi = 0.0_wp
    else
        do l = 0 , maxi
            l_real = l
            N = N + (1.0_wp)**l * binomial(maxi,l)/(x-l_real/K_big_real)
        end do
        phi = (1)**k_small
        phi = phi * binomial(maxi, k_small)
        phi = phi / (x - k_small_real / K_big_real)
        phi = phi / N
    end if
end function phi_p_K

function theta_p_K(x,p,K_big,k_small) result(theta)
    implicit none
    integer, intent(in) :: p , K_big, k_small
    integer :: l,i, maxi,k_new
    real(wp), intent(in) :: x
    real(wp) :: theta, x_new, check(K_big),tol = 1.0e-6_wp,K_big_real,k_small_real
    K_big_real = real(K_big,wp)
    k_small_real = real(k_small,wp)
    x_new = x-real(integer(x,p,K_big),wp)
    k_new = k_small-integer(x,p,K_big)
    theta = 0.0_wp
    do i = 0, K_big-1
        check(i+1) = real(i,wp) / K_big_real
    end do
    if (x == k_small_real / K_big_real)  then
        theta = 1.0_wp
    else if (any(abs(check - x) < tol)) then
        theta = 0.0_wp
    else
        theta = phi_p_K(x_new,p,K_big,k_new)
    end if
end function theta_p_K

end module PME_main

